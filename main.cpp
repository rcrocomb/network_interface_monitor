/**
    Author: Robert Crocombe
    Classification: Unclassified
    Initial Release Date:

*/

#include <set>

#include <signal.h>                                 // POSIX signal handling
#include <unistd.h>                                 // getopt
#include <string.h>
#include <stdint.h>

#include <vector>
#include <string>
#include <cstdlib>

#include "program_IO.h"
#include "network_stats.h"

////////////////////////////////////////////////////////////////////////////////
// Globals and Macros
////////////////////////////////////////////////////////////////////////////////

// to turn async signal into synchronous request to stop
static volatile sig_atomic_t stop;

namespace
{
    enum
    {
        DEFAULT_A_VALUE = 0
    };
}

struct commandline_options
{
    std::string interface;
    std::vector<std::string> filenames;

    commandline_options(int option_a = DEFAULT_A_VALUE):
        interface(),
        filenames()
    {

    }
};

namespace main_name
{
    const std::string NAME("main");
}

#define NAME main_name::NAME
#define ALWAYS(fmt, args...)  ALWAYS_WITH_NAME(NAME, fmt, ##args)
#define CPRINT(fmt, args...)  CPRINT_WITH_NAME(NAME, fmt, ##args)
#define VPRINT(fmt, args...)  VPRINT_WITH_NAME(NAME, fmt, ##args)
#define WARNING(fmt, args...) WARNING_WITH_NAME(NAME, fmt, ##args)
#define ERROR(fmt, args...) ERROR_WITH_NAME(NAME, fmt, ##args)
#define RUNTIME(fmt, args...) RUNTIME_WITH_NAME(NAME, fmt, ##args)
#define REPORT(fmt, args...) REPORT_WITH_NAME(NAME, fmt, ##args)

////////////////////////////////////////////////////////////////////////////////
// Prototypes
////////////////////////////////////////////////////////////////////////////////

void signal_handler(int signum, siginfo_t *info, void *p);
const char * signum_to_string(int signum);

////////////////////////////////////////////////////////////////////////////////
// Definitions
////////////////////////////////////////////////////////////////////////////////

/**

*/

void
signal_handler(int signum, siginfo_t *info, void *p)
{
    cprint("Caught signal %d: %s -- ",
               signum, signum_to_string(signum));

    if (!info)
    {
        cprint("NULL siginfo_t pointer!\n");
        if ((signum == SIGSEGV) || (signum == SIGBUS))
        {
            cprint("Attempting dirty shutdown *NOW*\n");
            kill(0, SIGINT);
            exit(0);
        }

        cprint("Attempting synchronous termination\n");
        stop = 1;
        return;
    }

    else if (info->si_errno != 0)
        cprint("si_errno is non-zero: %d\n", info->si_errno);
    else
        cprint("no error detected\n");

    switch(info->si_code)
    {
    case SI_QUEUE:  // sent via sigqueue()
        cprint("Sigqueue: pid is %d from user %d: value is %d\n",
                   info->si_pid, info->si_uid,
                   info->si_value.sival_int);
        break;

    case SI_USER:   // sent via kill() or sigsend()
        cprint("Signal sent from pid %d and user %d\n",
               info->si_pid, info->si_uid);
        // FALL THROUGH!
    default:        // not generated by user -- but reason is encoded
        switch(signum)
        {
        case SIGINT:
            cprint("SIGINT received: synchronous shutdown.\n");
            stop = 1;
            break;

        case SIGSEGV:
            cprint("SIGSEGV: segfault @ %12llx", (unsigned long long)info->si_addr);
            switch(info->si_code)
            {
            case SEGV_MAPERR:
                cprint(": address not mapped to object.\n");
                break;
            case SEGV_ACCERR:
                cprint(": invalid permissions for mapped object.\n");
                break;
            default:
                /* Regular generic segfault */
                cprint("\n");
            }

            cprint("Attempting dirty shutdown *NOW*\n");
            // send SIGINT signal to all processes in the process group.
            kill(0, SIGINT);
            exit(0);

            break;

        case SIGBUS:
            // cannot return from signal handler with SIGBUS, because the
            // processor's PC is pointing to the instruction where the fault
            // occurs, so it'd simply fault again.  So exit() and hope for
            // the best.
            cprint("SIGBUS: memory fault @ %016llx\n", (unsigned long long)info->si_addr);
            cprint("Attempting dirty shutdown *NOW*\n");
            // send SIGINT signal to all processes in the process group.
            kill(0, SIGINT);
            exit(0);

        case SIGUSR1:
            cprint("SIGUSR1: what?\n");
            break;

        case SIGUSR2:
            cprint("SIGUSR2: what?\n");
            break;

        case SIGCHLD:
            cprint("SIGCHLD: pid is %d, status is %d: ",
                   info->si_pid, info->si_status);
            switch(info->si_code)       // yes, switch on si_code again
            {
            case(CLD_EXITED):
                cprint("Child exited.\n");
                break;

            case(CLD_KILLED):
                cprint("Child killed.\n");
                break;

            case(CLD_DUMPED):
                cprint("Child terminated abnormally (and dumped core)).\n");
                stop = 1;
                break;

            case(CLD_TRAPPED): cprint("Child trapped while tracing.\n"); break;
            case(CLD_STOPPED): cprint("Child stopped.\n"); break;
            case(CLD_CONTINUED): cprint("Child is continuing.\n"); break;
            default:
                cprint("Yow: unknown child status of %d\n", info->si_code);
            }

            if (!stop)
            {
                warning("SIGCHLD when not terminating: boned?\n");
                cprint("Attempting dirty shutdown *NOW*\n");
                // send SIGINT signal to all processes in the process group.
                kill(0, SIGINT);
                exit(0);
            }

            break;
        default:
            cprint("Caught unhandled signal?\n");
        }
    }
}

const char *
signum_to_string(int signum)
{
    #define SIGNAME(a) case (a): return #a
    switch(signum)
    {
    SIGNAME(SIGHUP); SIGNAME(SIGINT); SIGNAME(SIGQUIT); SIGNAME(SIGILL);
    SIGNAME(SIGTRAP); SIGNAME(SIGABRT); SIGNAME(SIGFPE); SIGNAME(SIGKILL);
    SIGNAME(SIGBUS); SIGNAME(SIGSEGV); SIGNAME(SIGSYS); SIGNAME(SIGPIPE);
    SIGNAME(SIGALRM); SIGNAME(SIGTERM); SIGNAME(SIGUSR1); SIGNAME(SIGUSR2);
    SIGNAME(SIGCHLD); SIGNAME(SIGPWR); SIGNAME(SIGWINCH); SIGNAME(SIGURG);
    SIGNAME(SIGPOLL); SIGNAME(SIGSTOP); SIGNAME(SIGTSTP); SIGNAME(SIGCONT);
    SIGNAME(SIGTTIN); SIGNAME(SIGTTOU); SIGNAME(SIGVTALRM);
    SIGNAME(SIGPROF); SIGNAME(SIGXCPU); SIGNAME(SIGXFSZ);
    default: return "Unknown signal number!";
    }
    #undef SIGNAME
}

void
usage(void)
{
    ALWAYS("Don't");
}

long
arg_as_long(char *optarg, const std::string &option_string)
{
    char *endptr = 0;
    errno = 0;
    long value = std::strtol(optarg, &endptr, 0);
    if (errno)
        ERROR("Converting %s for '%s'", C(option_string), optarg);

    return value;
}

double
arg_as_double(char *optarg, const std::string &option_string)
{
    char *endptr = 0;
    errno = 0;
    double value = std::strtod(optarg, &endptr);
    if ((value == 0.0) && (endptr == optarg))
        RUNTIME("Unable to convert %s '%s' to float", C(option_string),
optarg);
    else if ((value == 0.0) && (errno == ERANGE))
        RUNTIME("Floating point %s underflows: '%s'", C(option_string),
optarg);

    return value;
}

void
get_commandline_options(int argc, char *argv[], commandline_options *options)
{
    using ::optarg;
    using ::opterr;

    int c;
    extern char *optarg;
    extern int opterr;
    opterr = 1;

    if (!options)
        RUNTIME("Null commandline options data struture");

    while ((c = getopt(argc, argv, "")) != -1)
    {
        switch (c)
        {
        case '?':
        default:
            usage();
            RUNTIME("Invalid commandline option");
        }
    }

    for ( ; !stop && (optind < argc); ++optind)
    {
        CPRINT("Adding filename '%s'\n", argv[optind]);
        options->filenames.push_back(argv[optind]);
    }

    if (options->filenames.size() == 0)
        RUNTIME("Must have a filename to proceed.\n");
}

////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////

void
do_monitor(void)
{
    network_stats stats;

    std::set<rx_fields> rx_stats;
    std::set<tx_fields> tx_stats;

    rx_stats.insert(RX_BYTES);
    rx_stats.insert(RX_PACKETS);

    tx_stats.insert(TX_BYTES);
    tx_stats.insert(TX_PACKETS);

    CPRINT("Setting Rx stats to update\n");
    stats.set_rx_stats_to_update(rx_stats);

    CPRINT("Setting Tx stats to update\n");
    stats.set_tx_stats_to_update(tx_stats);

    stats.update_all();
    uint64_t rx_bytes, rx_packets;
    uint64_t a_rx_bytes, a_rx_packets;
    uint64_t tx_bytes, tx_packets;
    uint64_t a_tx_bytes, a_tx_packets;

    rx_bytes = stats.get_rx_bytes();
    tx_bytes = stats.get_tx_bytes();

    rx_packets = stats.get_rx_packets();
    tx_packets = stats.get_tx_packets();

    while (!stop)
    {
        sleep(1);
        time_t now = time(0);
        stats.update_all();

        a_rx_bytes = stats.get_rx_bytes();
        a_tx_bytes = stats.get_tx_bytes();
        a_rx_packets = stats.get_rx_packets();
        a_tx_packets = stats.get_tx_packets();

        uint64_t diff_rx_bytes = a_rx_bytes - rx_bytes;
        uint64_t diff_tx_bytes = a_tx_bytes - tx_bytes;

        uint64_t diff_rx_packets = a_rx_packets - rx_packets;
        uint64_t diff_tx_packets = a_tx_packets - tx_packets;

        ALWAYS("%lu : Rx bytes: %llu -> %llu : %llu\n",
               (unsigned long)now,
               (unsigned long long)rx_bytes,
               (unsigned long long)a_rx_bytes,
               (unsigned long long)diff_rx_bytes);

        ALWAYS("%lu : Tx bytes: %llu -> %llu : %llu\n",
               (unsigned long)now,
               (unsigned long long)tx_bytes,
               (unsigned long long)a_tx_bytes,
               (unsigned long long)diff_tx_bytes);

        ALWAYS("%lu : Rx packets: %llu -> %llu : %llu\n",
               (unsigned long)now,
               (unsigned long long)rx_packets,
               (unsigned long long)a_rx_packets,
               (unsigned long long)diff_rx_packets);

        ALWAYS("%lu : Tx packets: %llu -> %llu : %llu\n",
               (unsigned long)now,
               (unsigned long long)tx_packets,
               (unsigned long long)a_tx_packets,
               (unsigned long long)diff_tx_packets);

        rx_bytes = a_rx_bytes;
        tx_bytes = a_tx_bytes;
        rx_packets = a_rx_packets;
        tx_packets = a_tx_packets;
    }
}

int
main(int argc, char *argv[])
{
    struct sigaction action;
    int error = 0;

    std::cout.sync_with_stdio();

    // Setup signal handling
    action.sa_sigaction = signal_handler;
    action.sa_flags = SA_SIGINFO;
    error += sigaction(SIGINT, &action, 0);
    error += sigaction(SIGSEGV, &action, 0);
    if (error)
    {
        REPORT("Error in sigaction");
        return 0;
    } else
        CPRINT("Signal handler installed.\n");

    try
    {
        do_monitor();
    } catch (std::exception &e)
    {
        ALWAYS("Caught exception.\n");
    } catch (...)
    {
        ALWAYS("Caught non-exception.\n");
    }

    return 0;
}

#undef NAME
#undef ALWAYS
#undef CPRINT
#undef VPRINT
#undef WARNING
#undef ERROR
#undef RUNTIME
#undef REPORT

